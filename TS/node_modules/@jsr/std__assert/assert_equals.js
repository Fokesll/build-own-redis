// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { equal } from "./equal.js";
import { format } from "./_format.js";
import { AssertionError } from "./assertion_error.js";
import { red } from "@jsr/std__fmt/colors";
import { buildMessage, diff, diffstr } from "./_diff.js";
import { CAN_NOT_DISPLAY } from "./_constants.js";
/**
 * Make an assertion that `actual` and `expected` are equal, deeply. If not
 * deeply equal, then throw.
 *
 * Type parameter can be specified to ensure values under comparison have the
 * same type.
 *
 * @example
 * ```ts
 * import { assertEquals } from "@std/assert/assert-equals";
 *
 * assertEquals("world", "world"); // Doesn't throw
 * assertEquals("hello", "world"); // Throws
 * ```
 *
 * Note: formatter option is experimental and may be removed in the future.
 */ export function assertEquals(actual, expected, msg, options = {}) {
  if (equal(actual, expected)) {
    return;
  }
  const { formatter = format } = options;
  const msgSuffix = msg ? `: ${msg}` : ".";
  let message = `Values are not equal${msgSuffix}`;
  const actualString = formatter(actual);
  const expectedString = formatter(expected);
  try {
    const stringDiff = typeof actual === "string" && typeof expected === "string";
    const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
    const diffMsg = buildMessage(diffResult, {
      stringDiff
    }).join("\n");
    message = `${message}\n${diffMsg}`;
  } catch  {
    message = `${message}\n${red(CAN_NOT_DISPLAY)} + \n\n`;
  }
  throw new AssertionError(message);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2VydF9lcXVhbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyxTQUFTLEtBQUsscUJBQXFCO0FBQ25DLFNBQVMsTUFBTSx1QkFBdUI7QUFDdEMsU0FBUyxjQUFjLCtCQUErQjtBQUN0RCxTQUFTLEdBQUcsK0JBQXdDO0FBQ3BELFNBQVMsWUFBWSxFQUFFLElBQUksRUFBRSxPQUFPLHFCQUFxQjtBQUN6RCxTQUFTLGVBQWUsMEJBQTBCO0FBRWxEOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0QsT0FBTyxTQUFTLGFBQ2QsTUFBUyxFQUNULFFBQVcsRUFDWCxHQUFZLEVBQ1osVUFBc0QsQ0FBQyxDQUFDO0VBRXhELElBQUksTUFBTSxRQUFRLFdBQVc7SUFDM0I7RUFDRjtFQUNBLE1BQU0sRUFBRSxZQUFZLE1BQU0sRUFBRSxHQUFHO0VBQy9CLE1BQU0sWUFBWSxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHO0VBQ3JDLElBQUksVUFBVSxDQUFDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQztFQUVoRCxNQUFNLGVBQWUsVUFBVTtFQUMvQixNQUFNLGlCQUFpQixVQUFVO0VBQ2pDLElBQUk7SUFDRixNQUFNLGFBQWEsQUFBQyxPQUFPLFdBQVcsWUFDbkMsT0FBTyxhQUFhO0lBQ3ZCLE1BQU0sYUFBYSxhQUNmLFFBQVEsUUFBa0IsWUFDMUIsS0FBSyxhQUFhLEtBQUssQ0FBQyxPQUFPLGVBQWUsS0FBSyxDQUFDO0lBQ3hELE1BQU0sVUFBVSxhQUFhLFlBQVk7TUFBRTtJQUFXLEdBQUcsSUFBSSxDQUFDO0lBQzlELFVBQVUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxFQUFFLFFBQVEsQ0FBQztFQUNwQyxFQUFFLE9BQU07SUFDTixVQUFVLENBQUMsRUFBRSxRQUFRLEVBQUUsRUFBRSxJQUFJLGlCQUFpQixPQUFPLENBQUM7RUFDeEQ7RUFDQSxNQUFNLElBQUksZUFBZTtBQUMzQiJ9