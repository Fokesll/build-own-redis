// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { bgGreen, bgRed, bold, gray, green, red, white } from "@jsr/std__fmt/colors";
export const DiffType = {
  removed: "removed",
  common: "common",
  added: "added"
};
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse) {
  const common = [];
  if (A.length === 0 || B.length === 0) return [];
  for(let i = 0; i < Math.min(A.length, B.length); i += 1){
    const a = reverse ? A[A.length - i - 1] : A[i];
    const b = reverse ? B[B.length - i - 1] : B[i];
    if (a !== undefined && a === b) {
      common.push(a);
    } else {
      return common;
    }
  }
  return common;
}
function ensureDefined(item) {
  if (item === undefined) {
    throw Error("Unexpected missing FarthestPoint");
  }
  return item;
}
/**
 * Renders the differences between the actual and expected values
 * @param A Actual value
 * @param B Expected value
 */ export function diff(A, B) {
  const prefixCommon = createCommon(A, B);
  const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
  A = suffixCommon.length ? A.slice(prefixCommon.length, -suffixCommon.length) : A.slice(prefixCommon.length);
  B = suffixCommon.length ? B.slice(prefixCommon.length, -suffixCommon.length) : B.slice(prefixCommon.length);
  const swapped = B.length > A.length;
  [A, B] = swapped ? [
    B,
    A
  ] : [
    A,
    B
  ];
  const M = A.length;
  const N = B.length;
  if (!M && !N && !suffixCommon.length && !prefixCommon.length) return [];
  if (!N) {
    return [
      ...prefixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        })),
      ...A.map((a)=>({
          type: swapped ? DiffType.added : DiffType.removed,
          value: a
        })),
      ...suffixCommon.map((c)=>({
          type: DiffType.common,
          value: c
        }))
    ];
  }
  const offset = N;
  const delta = M - N;
  const size = M + N + 1;
  const fp = Array.from({
    length: size
  }, ()=>({
      y: -1,
      id: -1
    }));
  /**
   * INFO:
   * This buffer is used to save memory and improve performance.
   * The first half is used to save route and last half is used to save diff
   * type.
   * This is because, when I kept new uint8array area to save type,performance
   * worsened.
   */ const routes = new Uint32Array((M * N + size + 1) * 2);
  const diffTypesPtrOffset = routes.length / 2;
  let ptr = 0;
  let p = -1;
  function backTrace(A, B, current, swapped) {
    const M = A.length;
    const N = B.length;
    const result = [];
    let a = M - 1;
    let b = N - 1;
    let j = routes[current.id];
    let type = routes[current.id + diffTypesPtrOffset];
    while(true){
      if (!j && !type) break;
      const prev = j;
      if (type === REMOVED) {
        result.unshift({
          type: swapped ? DiffType.removed : DiffType.added,
          value: B[b]
        });
        b -= 1;
      } else if (type === ADDED) {
        result.unshift({
          type: swapped ? DiffType.added : DiffType.removed,
          value: A[a]
        });
        a -= 1;
      } else {
        result.unshift({
          type: DiffType.common,
          value: A[a]
        });
        a -= 1;
        b -= 1;
      }
      j = routes[prev];
      type = routes[prev + diffTypesPtrOffset];
    }
    return result;
  }
  function createFP(slide, down, k, M) {
    if (slide && slide.y === -1 && down && down.y === -1) {
      return {
        y: 0,
        id: 0
      };
    }
    const isAdding = down?.y === -1 || k === M || (slide?.y || 0) > (down?.y || 0) + 1;
    if (slide && isAdding) {
      const prev = slide.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = ADDED;
      return {
        y: slide.y,
        id: ptr
      };
    } else if (down && !isAdding) {
      const prev = down.id;
      ptr++;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = REMOVED;
      return {
        y: down.y + 1,
        id: ptr
      };
    } else {
      throw new Error("Unexpected missing FarthestPoint");
    }
  }
  function snake(k, slide, down, _offset, A, B) {
    const M = A.length;
    const N = B.length;
    if (k < -N || M < k) return {
      y: -1,
      id: -1
    };
    const fp = createFP(slide, down, k, M);
    while(fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]){
      const prev = fp.id;
      ptr++;
      fp.id = ptr;
      fp.y += 1;
      routes[ptr] = prev;
      routes[ptr + diffTypesPtrOffset] = COMMON;
    }
    return fp;
  }
  let currentFP = ensureDefined(fp[delta + offset]);
  while(currentFP && currentFP.y < N){
    p = p + 1;
    for(let k = -p; k < delta; ++k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    for(let k = delta + p; k > delta; --k){
      fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
    }
    fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
    currentFP = ensureDefined(fp[delta + offset]);
  }
  return [
    ...prefixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      })),
    ...backTrace(A, B, currentFP, swapped),
    ...suffixCommon.map((c)=>({
        type: DiffType.common,
        value: c
      }))
  ];
}
/**
 * Renders the differences between the actual and expected strings
 * Partially inspired from https://github.com/kpdecker/jsdiff
 * @param A Actual string
 * @param B Expected string
 */ export function diffstr(A, B) {
  function unescape(string) {
    // unescape invisible characters.
    // ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#escape_sequences
    return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n");
  }
  function tokenize(string, { wordDiff = false } = {}) {
    if (wordDiff) {
      // Split string on whitespace symbols
      const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
      // Extended Latin character set
      const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
      // Join boundary splits that we do not consider to be boundaries and merge empty strings surrounded by word chars
      for(let i = 0; i < tokens.length - 1; i++){
        const token = tokens[i];
        const tokenPlusTwo = tokens[i + 2];
        if (!tokens[i + 1] && token && tokenPlusTwo && words.test(token) && words.test(tokenPlusTwo)) {
          tokens[i] += tokenPlusTwo;
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens.filter((token)=>token);
    } else {
      // Split string on new lines symbols
      const tokens = [];
      const lines = string.split(/(\n|\r\n)/);
      // Ignore final empty token when text ends with a newline
      if (!lines[lines.length - 1]) {
        lines.pop();
      }
      // Merge the content and line separators into single tokens
      for (const [i, line] of lines.entries()){
        if (i % 2) {
          tokens[tokens.length - 1] += line;
        } else {
          tokens.push(line);
        }
      }
      return tokens;
    }
  }
  // Create details by filtering relevant word-diff for current line
  // and merge "space-diff" if surrounded by word-diff for cleaner displays
  function createDetails(line, tokens) {
    return tokens.filter(({ type })=>type === line.type || type === DiffType.common).map((result, i, t)=>{
      const token = t[i - 1];
      if (result.type === DiffType.common && token && token.type === t[i + 1]?.type && /\s+/.test(result.value)) {
        return {
          ...result,
          type: token.type
        };
      }
      return result;
    });
  }
  // Compute multi-line diff
  const diffResult = diff(tokenize(`${unescape(A)}\n`), tokenize(`${unescape(B)}\n`));
  const added = [];
  const removed = [];
  for (const result of diffResult){
    if (result.type === DiffType.added) {
      added.push(result);
    }
    if (result.type === DiffType.removed) {
      removed.push(result);
    }
  }
  // Compute word-diff
  const hasMoreRemovedLines = added.length < removed.length;
  const aLines = hasMoreRemovedLines ? added : removed;
  const bLines = hasMoreRemovedLines ? removed : added;
  for (const a of aLines){
    let tokens = [];
    let b;
    // Search another diff line with at least one common token
    while(bLines.length){
      b = bLines.shift();
      const tokenized = [
        tokenize(a.value, {
          wordDiff: true
        }),
        tokenize(b?.value ?? "", {
          wordDiff: true
        })
      ];
      if (hasMoreRemovedLines) tokenized.reverse();
      tokens = diff(tokenized[0], tokenized[1]);
      if (tokens.some(({ type, value })=>type === DiffType.common && value.trim().length)) {
        break;
      }
    }
    // Register word-diff details
    a.details = createDetails(a, tokens);
    if (b) {
      b.details = createDetails(b, tokens);
    }
  }
  return diffResult;
}
/**
 * Colors the output of assertion diffs
 * @param diffType Difference type, either added or removed
 */ function createColor(diffType, { background = false } = {}) {
  // TODO(@littledivy): Remove this when we can detect
  // true color terminals.
  // https://github.com/denoland/deno_std/issues/2575
  background = false;
  switch(diffType){
    case DiffType.added:
      return (s)=>background ? bgGreen(white(s)) : green(bold(s));
    case DiffType.removed:
      return (s)=>background ? bgRed(white(s)) : red(bold(s));
    default:
      return white;
  }
}
/**
 * Prefixes `+` or `-` in diff output
 * @param diffType Difference type, either added or removed
 */ function createSign(diffType) {
  switch(diffType){
    case DiffType.added:
      return "+   ";
    case DiffType.removed:
      return "-   ";
    default:
      return "    ";
  }
}
export function buildMessage(diffResult, { stringDiff = false } = {}) {
  const messages = [];
  const diffMessages = [];
  messages.push("");
  messages.push("");
  messages.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
  messages.push("");
  messages.push("");
  diffResult.forEach((result)=>{
    const c = createColor(result.type);
    const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
        background: true
      })(detail.value) : detail.value).join("") ?? result.value;
    diffMessages.push(c(`${createSign(result.type)}${line}`));
  });
  messages.push(...stringDiff ? [
    diffMessages.join("")
  ] : diffMessages);
  messages.push("");
  return messages;
}
//# sourceMappingURL=data:application/json;base64,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