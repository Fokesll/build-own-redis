// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { assertEquals } from "./assert_equals.js";
/**
 * Make an assertion that `actual` object is a subset of `expected` object,
 * deeply. If not, then throw.
 *
 * @example
 * ```ts
 * import { assertObjectMatch } from "@std/assert/assert-object-match";
 *
 * assertObjectMatch({ foo: "bar" }, { foo: "bar" }); // Doesn't throw
 * assertObjectMatch({ foo: "bar" }, { foo: "baz" }); // Throws
 * ```
 */ export function assertObjectMatch(// deno-lint-ignore no-explicit-any
actual, expected, msg) {
  function filter(a, b) {
    const seen = new WeakMap();
    return fn(a, b);
    function fn(a, b) {
      // Prevent infinite loop with circular references with same filter
      if (seen.has(a) && seen.get(a) === b) {
        return a;
      }
      try {
        seen.set(a, b);
      } catch (err) {
        if (err instanceof TypeError) {
          throw new TypeError(`Cannot assertObjectMatch ${a === null ? null : `type ${typeof a}`}`);
        } else throw err;
      }
      // Filter keys and symbols which are present in both actual and expected
      const filtered = {};
      const entries = [
        ...Object.getOwnPropertyNames(a),
        ...Object.getOwnPropertySymbols(a)
      ].filter((key)=>key in b).map((key)=>[
          key,
          a[key]
        ]);
      for (const [key, value] of entries){
        // On array references, build a filtered array and filter nested objects inside
        if (Array.isArray(value)) {
          const subset = b[key];
          if (Array.isArray(subset)) {
            filtered[key] = fn({
              ...value
            }, {
              ...subset
            });
            continue;
          }
        } else if (value instanceof RegExp) {
          filtered[key] = value;
          continue;
        } else if (typeof value === "object" && value !== null) {
          const subset = b[key];
          if (typeof subset === "object" && subset) {
            // When both operands are maps, build a filtered map with common keys and filter nested objects inside
            if (value instanceof Map && subset instanceof Map) {
              filtered[key] = new Map([
                ...value
              ].filter(([k])=>subset.has(k)).map(([k, v])=>[
                  k,
                  typeof v === "object" ? fn(v, subset.get(k)) : v
                ]));
              continue;
            }
            // When both operands are set, build a filtered set with common values
            if (value instanceof Set && subset instanceof Set) {
              filtered[key] = new Set([
                ...value
              ].filter((v)=>subset.has(v)));
              continue;
            }
            filtered[key] = fn(value, subset);
            continue;
          }
        }
        filtered[key] = value;
      }
      return filtered;
    }
  }
  return assertEquals(// get the intersection of "actual" and "expected"
  // side effect: all the instances' constructor field is "Object" now.
  filter(actual, expected), // set (nested) instances' constructor field to be "Object" without changing expected value.
  // see https://github.com/denoland/deno_std/pull/1419
  filter(expected, expected), msg);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2VydF9vYmplY3RfbWF0Y2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyxTQUFTLFlBQVksNkJBQTZCO0FBRWxEOzs7Ozs7Ozs7OztDQVdDLEdBQ0QsT0FBTyxTQUFTLGtCQUNkLG1DQUFtQztBQUNuQyxNQUFnQyxFQUNoQyxRQUFzQyxFQUN0QyxHQUFZO0VBSVosU0FBUyxPQUFPLENBQVEsRUFBRSxDQUFRO0lBQ2hDLE1BQU0sT0FBTyxJQUFJO0lBQ2pCLE9BQU8sR0FBRyxHQUFHO0lBRWIsU0FBUyxHQUFHLENBQVEsRUFBRSxDQUFRO01BQzVCLGtFQUFrRTtNQUNsRSxJQUFJLEFBQUMsS0FBSyxHQUFHLENBQUMsTUFBUSxLQUFLLEdBQUcsQ0FBQyxPQUFPLEdBQUk7UUFDeEMsT0FBTztNQUNUO01BQ0EsSUFBSTtRQUNGLEtBQUssR0FBRyxDQUFDLEdBQUc7TUFDZCxFQUFFLE9BQU8sS0FBSztRQUNaLElBQUksZUFBZSxXQUFXO1VBQzVCLE1BQU0sSUFBSSxVQUNSLENBQUMseUJBQXlCLEVBQ3hCLE1BQU0sT0FBTyxPQUFPLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQ3ZDLENBQUM7UUFFTixPQUFPLE1BQU07TUFDZjtNQUNBLHdFQUF3RTtNQUN4RSxNQUFNLFdBQVcsQ0FBQztNQUNsQixNQUFNLFVBQVU7V0FDWCxPQUFPLG1CQUFtQixDQUFDO1dBQzNCLE9BQU8scUJBQXFCLENBQUM7T0FDakMsQ0FDRSxNQUFNLENBQUMsQ0FBQyxNQUFRLE9BQU8sR0FDdkIsR0FBRyxDQUFDLENBQUMsTUFBUTtVQUFDO1VBQUssQ0FBQyxDQUFDLElBQWM7U0FBQztNQUN2QyxLQUFLLE1BQU0sQ0FBQyxLQUFLLE1BQU0sSUFBSSxRQUFTO1FBQ2xDLCtFQUErRTtRQUMvRSxJQUFJLE1BQU0sT0FBTyxDQUFDLFFBQVE7VUFDeEIsTUFBTSxTQUFTLEFBQUMsQ0FBVyxDQUFDLElBQUk7VUFDaEMsSUFBSSxNQUFNLE9BQU8sQ0FBQyxTQUFTO1lBQ3pCLFFBQVEsQ0FBQyxJQUFJLEdBQUcsR0FBRztjQUFFLEdBQUcsS0FBSztZQUFDLEdBQUc7Y0FBRSxHQUFHLE1BQU07WUFBQztZQUM3QztVQUNGO1FBQ0YsT0FDSyxJQUFJLGlCQUFpQixRQUFRO1VBQ2hDLFFBQVEsQ0FBQyxJQUFJLEdBQUc7VUFDaEI7UUFDRixPQUNLLElBQUksT0FBTyxVQUFVLFlBQVksVUFBVSxNQUFNO1VBQ3BELE1BQU0sU0FBUyxBQUFDLENBQVcsQ0FBQyxJQUFJO1VBQ2hDLElBQUksQUFBQyxPQUFPLFdBQVcsWUFBYSxRQUFRO1lBQzFDLHNHQUFzRztZQUN0RyxJQUFJLEFBQUMsaUJBQWlCLE9BQVMsa0JBQWtCLEtBQU07Y0FDckQsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLElBQ2xCO21CQUFJO2VBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBSyxPQUFPLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUM1QyxDQUFDLEdBQUcsRUFBRSxHQUNIO2tCQUFDO2tCQUFHLE9BQU8sTUFBTSxXQUFXLEdBQUcsR0FBRyxPQUFPLEdBQUcsQ0FBQyxNQUFNO2lCQUFFO2NBRTVEO1lBQ0Y7WUFDQSxzRUFBc0U7WUFDdEUsSUFBSSxBQUFDLGlCQUFpQixPQUFTLGtCQUFrQixLQUFNO2NBQ3JELFFBQVEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJO21CQUFJO2VBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFNLE9BQU8sR0FBRyxDQUFDO2NBQzVEO1lBQ0Y7WUFDQSxRQUFRLENBQUMsSUFBSSxHQUFHLEdBQUcsT0FBZ0I7WUFDbkM7VUFDRjtRQUNGO1FBQ0EsUUFBUSxDQUFDLElBQUksR0FBRztNQUNsQjtNQUNBLE9BQU87SUFDVDtFQUNGO0VBQ0EsT0FBTyxhQUNMLGtEQUFrRDtFQUNsRCxxRUFBcUU7RUFDckUsT0FBTyxRQUFRLFdBQ2YsNEZBQTRGO0VBQzVGLHFEQUFxRDtFQUNyRCxPQUFPLFVBQVUsV0FDakI7QUFFSiJ9