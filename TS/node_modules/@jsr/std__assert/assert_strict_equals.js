// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.
// This module is browser compatible.
import { format } from "./_format.js";
import { AssertionError } from "./assertion_error.js";
import { buildMessage, diff, diffstr } from "./_diff.js";
import { CAN_NOT_DISPLAY } from "./_constants.js";
import { red } from "@jsr/std__fmt/colors";
/**
 * Make an assertion that `actual` and `expected` are strictly equal. If
 * not then throw.
 *
 * @example
 * ```ts
 * import { assertStrictEquals } from "@std/assert/assert-strict-equals";
 *
 * const a = {};
 * const b = a;
 * assertStrictEquals(a, b); // Doesn't throw
 *
 * const c = {};
 * const d = {};
 * assertStrictEquals(c, d); // Throws
 * ```
 */ export function assertStrictEquals(actual, expected, msg) {
  if (Object.is(actual, expected)) {
    return;
  }
  const msgSuffix = msg ? `: ${msg}` : ".";
  let message;
  const actualString = format(actual);
  const expectedString = format(expected);
  if (actualString === expectedString) {
    const withOffset = actualString.split("\n").map((l)=>`    ${l}`).join("\n");
    message = `Values have the same structure but are not reference-equal${msgSuffix}\n\n${red(withOffset)}\n`;
  } else {
    try {
      const stringDiff = typeof actual === "string" && typeof expected === "string";
      const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
      const diffMsg = buildMessage(diffResult, {
        stringDiff
      }).join("\n");
      message = `Values are not strictly equal${msgSuffix}\n${diffMsg}`;
    } catch  {
      message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
    }
  }
  throw new AssertionError(message);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2VydF9zdHJpY3RfZXF1YWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsU0FBUyxNQUFNLHVCQUF1QjtBQUN0QyxTQUFTLGNBQWMsK0JBQStCO0FBQ3RELFNBQVMsWUFBWSxFQUFFLElBQUksRUFBRSxPQUFPLHFCQUFxQjtBQUN6RCxTQUFTLGVBQWUsMEJBQTBCO0FBQ2xELFNBQVMsR0FBRywrQkFBd0M7QUFFcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRCxPQUFPLFNBQVMsbUJBQ2QsTUFBZSxFQUNmLFFBQVcsRUFDWCxHQUFZO0VBRVosSUFBSSxPQUFPLEVBQUUsQ0FBQyxRQUFRLFdBQVc7SUFDL0I7RUFDRjtFQUVBLE1BQU0sWUFBWSxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxHQUFHO0VBQ3JDLElBQUk7RUFFSixNQUFNLGVBQWUsT0FBTztFQUM1QixNQUFNLGlCQUFpQixPQUFPO0VBRTlCLElBQUksaUJBQWlCLGdCQUFnQjtJQUNuQyxNQUFNLGFBQWEsYUFDaEIsS0FBSyxDQUFDLE1BQ04sR0FBRyxDQUFDLENBQUMsSUFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFDckIsSUFBSSxDQUFDO0lBQ1IsVUFDRSxDQUFDLDBEQUEwRCxFQUFFLFVBQVUsSUFBSSxFQUN6RSxJQUFJLFlBQ0wsRUFBRSxDQUFDO0VBQ1IsT0FBTztJQUNMLElBQUk7TUFDRixNQUFNLGFBQWEsQUFBQyxPQUFPLFdBQVcsWUFDbkMsT0FBTyxhQUFhO01BQ3ZCLE1BQU0sYUFBYSxhQUNmLFFBQVEsUUFBa0IsWUFDMUIsS0FBSyxhQUFhLEtBQUssQ0FBQyxPQUFPLGVBQWUsS0FBSyxDQUFDO01BQ3hELE1BQU0sVUFBVSxhQUFhLFlBQVk7UUFBRTtNQUFXLEdBQUcsSUFBSSxDQUFDO01BQzlELFVBQVUsQ0FBQyw2QkFBNkIsRUFBRSxVQUFVLEVBQUUsRUFBRSxRQUFRLENBQUM7SUFDbkUsRUFBRSxPQUFNO01BQ04sVUFBVSxDQUFDLEVBQUUsRUFBRSxJQUFJLGlCQUFpQixPQUFPLENBQUM7SUFDOUM7RUFDRjtFQUVBLE1BQU0sSUFBSSxlQUFlO0FBQzNCIn0=